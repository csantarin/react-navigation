{"version":3,"sources":["withNavigationFocus.tsx"],"names":["withNavigation","Component","componentDisplayName","displayName","name","WrappedComponent","wrappedComponentDisplayName","ComponentWithNavigation","props","isFocused","navigation","onRef"],"mappings":";;;;;;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;AAGA,MAAMA,cAAc,GAIlBC,SAJqB,IAKlB;AA8BD;AAaF,QAAMC,oBAAoB,GAAID,SAAD,CAA6CE,WAA7C,IAA4DF,SAAS,CAACG,IAAnG;AACA,QAAMC,gBAAgB,GAAGJ,SAAzB;AACA,QAAMK,2BAA2B,4BAAqBJ,oBAArB,MAAjC;;AAEA,QAAMK,uBAAuB,GAAIC,KAAD,IAAqB;AACnD,UAAMC,SAAS,GAAG,2BAAlB;AACA,UAAMC,UAAU,GAAG,mCAAnB;AAEA;AAAA;AACA;AACA;AACA;AACA;AACE,0BAAC,gBAAD,eACMF,KADN;AAEE,QAAA,GAAG,EAAEA,KAAK,CAACG,KAFb;AAGE,QAAA,SAAS,EAAEF,SAHb;AAIE,QAAA,UAAU,EAAEC;AAJd;AALF;AAYD,GAhBD;;AAkBA,qCAAqBH,uBAArB,EAA8CN,SAA9C;AAEAM,EAAAA,uBAAuB,CAACJ,WAAxB,GAAsCG,2BAAtC,CAnEG,CAqEH;AACA;AACA;;AA8BE;AAEF,SAAOC,uBAAP;AACD,CA7GD;;eA+GeP,c","sourcesContent":["/* eslint-disable prettier/prettier */\nimport * as React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { NavigationProp, useIsFocused } from '@react-navigation/native';\nimport useCompatNavigation from './useCompatNavigation';\nimport type { NavigationParams } from './types';\n\nconst withNavigation = <\n  C extends React.JSXElementConstructor<{}>,\n  NP extends NavigationParams = NavigationParams\n>(\n  Component: C\n) => {\n  type P = React.ComponentProps<C>;\n  type OnRef\n    //#region OnRef exhaustive types...\n    // class Screen extends React.Component {}\n    = C extends React.ComponentClass<{}>\n      ? React.LegacyRef<InstanceType<C>>\n\n    // const Screen = React.memo(React.forwardRef((props, ref) => <></>));\n    : C extends React.MemoExoticComponent<React.ForwardRefExoticComponent<{}>>\n      ? React.RefAttributes<React.ElementRef<C>>['ref']\n\n    // const Screen = React.memo((props) => <></>);\n    : C extends React.MemoExoticComponent<(props: {}) => React.ReactElement | null>\n      ? never\n\n    // const Screen = React.forwardRef((props, ref) => <></>);\n    : C extends React.ForwardRefExoticComponent<{}>\n      ? React.RefAttributes<React.ElementRef<C>>['ref']\n\n    // const Screen = React.memo(((props, ref) => <></>) as React.FunctionComponent);\n    : C extends React.NamedExoticComponent<{}>\n      ? never\n\n    // const Screen = (props, ref) => <></>;\n    : C extends (props: {}) => React.ReactElement | null | undefined\n      ? never\n\n    // unknown\n    : never;\n    //#endregion\n  type WrappedP = P & {\n    /**\n     * **NOTE**: Overriden by `.onRef` prop. Do not use `.ref`.\n     *           As per official React Navigation 5 API, use `.onRef` instead!\n     */\n    ref?: never;\n    /**\n     * Forwards ref to the wrapped component.\n     */\n    onRef?: OnRef;\n  };\n\n  const componentDisplayName = (Component as React.ComponentType<WrappedP>).displayName || Component.name;\n  const WrappedComponent = Component as unknown as React.ComponentType<WrappedP>;\n  const wrappedComponentDisplayName = `withNavigation(${componentDisplayName})`;\n\n  const ComponentWithNavigation = (props: WrappedP) => {\n    const isFocused = useIsFocused();\n    const navigation = useCompatNavigation<NavigationProp<NP>>();\n\n    return (\n    // @ts-expect-error: type checking HOC is hard\n    // if we hadn't override the built-in ref with our custom onRef (official API since v4!!!), this\n    // would've been fine without bypassing the type checking. unfortunately, v4 & v5/compat spec is\n    // like this, so, the bypass has to stay to ease the implementation...\n      <WrappedComponent\n        {...props}\n        ref={props.onRef}\n        isFocused={isFocused}\n        navigation={navigation}\n      />\n    );\n  };\n\n  hoistNonReactStatics(ComponentWithNavigation, Component);\n\n  ComponentWithNavigation.displayName = wrappedComponentDisplayName;\n\n  // 1. Inject HOC-specific props.\n  // 2. Retain C-specific props.\n  // 3. Retain C-specific statics.\n  type WithStatics<T> = T & Pick<C, keyof C>;\n  type NavigationComponentType\n    //#region NavigationComponentType exhaustive types...\n    // class Screen extends React.Component {}\n    = C extends React.ComponentClass<{}>\n      ? C & React.ComponentClass<WrappedP>\n\n    // const Screen = React.memo(React.forwardRef((props, ref) => <></>));\n    : C extends React.MemoExoticComponent<React.ForwardRefExoticComponent<{}>>\n      ? WithStatics<React.MemoExoticComponent<(props: WrappedP) => ReturnType<C>>>\n\n    // const Screen = React.memo((props) => <></>);\n    : C extends React.MemoExoticComponent<(props: {}) => React.ReactElement | null>\n      ? C\n\n    // const Screen = React.forwardRef((props, ref) => <></>);\n    : C extends React.ForwardRefExoticComponent<{}>\n      ? WithStatics<React.ForwardRefExoticComponent<WrappedP>>\n\n    // const Screen = React.memo(((props, ref) => <></>) as React.FunctionComponent);\n    : C extends React.NamedExoticComponent<{}>\n      ? C\n\n    // const Screen = (props, ref) => <></>;\n    : C extends (props: {}) => React.ReactElement | null | undefined\n      ? C\n\n    // unknown\n    : C;\n    //#endregion\n\n  return ComponentWithNavigation as NavigationComponentType;\n};\n\nexport default withNavigation;\n"]}